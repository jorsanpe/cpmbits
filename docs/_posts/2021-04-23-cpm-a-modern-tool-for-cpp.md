---
layout: post
title: "cpm: A Modern Tool for C/C++"
author: Jordi SÃ¡nchez
---

Unlike other more modern languages, C/C++ does not have a unified centralized tool for package and project management. Take for example `pip`; this tool offers an ecosystem from which developers can greatly benefit. It speeds up development, as dependencies are just one command away, without the need for complex installation recipes or hunting for repositories. Python is not the only one to offer a "dependency hub"; others like Java, Ruby or JavaScript also have their own ecosystems.

The main goal of cpm is to offer an ecosystem for C/C++ developers. It is composed of two main ingredients: the command line tool and the bits repository. Following, we present a step by step tutorial, after which you should end up with a running application. We try to maintain this tutorial to be valid for the latest version of cpm which, by the time of this writing, is version 1.6. You might find more information in your `project.yaml` file than what is presented here but you can safely ignore the extra parts in your project descriptor for this tutorial.

## Tutorial

cpm has been developed using Python 3.7. It can be installed using `pip`:

```
pip install cpm-cli
```

The cpm command line tool is not a build system, it's an orchestrator, so two additional tools are required in order to compile the project sources. First, cpm generates compilation recipes for <a href="https://cmake.org" target="_blank" rel="noopener">CMake</a>. Second, it uses the CMake <a href="https://ninja-build.org" target="_blank" rel="noopener">Ninja</a> generator. Needless to say that a C/C++ compiler is also required. cpm does not rely on any particular version of the aforementioned tools, so if you install the latest version of each you should be good to go. You can avoid depending on these tools by using the integration of cpm with Docker, but we will talk about that some other time.

### Creating a new Project

Creating a new project is straightforward:

```bash
$ cpm create awesome-project
```

The newly created project includes a hello world template that can be built right away:

```bash
$ cd awesome-project
```

Let's take a look at the project contents. Right now, they are:

```bash
$ ls
project.yaml
main.cpp
tests
```

The `project.yaml` file is the project descriptor and it contains the project configuration as defined by the user. After creation, it only contains the project name. The `main.cpp` file is the program entry point and at the time of writing this tutorial it is required to be at the project root (the reasons for this are beyond the scope of this tutorial but they are related to the current implementation of the tests compilation).

New projects are created with sample "Hello World" code, so they can be built right away. The build files are placed in the `build` folder so in order to run the compiled project:

```bash
$ cpm build
$ ./build/awesome-project
Hello World!
```

After building the project, you can see that cpm has generated a couple of things. The `CMakeLists.txt` file contains the compilation recipe for CMake. The `build` directory is generated by CMake and Ninja and contains the project compilation. Both elements are dynamically generated by cpm so there's no need to keep them around. You can see that when the project is cleaned, both files are deleted:

```bash
$ cpm clean
```

Beware that the project descriptor is considered to be owned by the developer so by design cpm will never modify it. Maybe in the future it will for convenience, for example, for automating the adding or removal of packages. But we're getting ahead of ourselves. Let's talk about packages.

### Packages

Projects in cpm are structured around <strong>packages</strong>. A package is a collection of (hopefully) related code that can be addressed from the package root. They try to be analogous to Python or Java packages. Let's see how they work with an example of a package named `multiplication`.

First, we have to create the package root directory:

```bash
$ mkdir multiplication
```

Second, edit the `project.yaml` file and declare the package:

```yaml
name: awesome-project
build:
  packages:
    multiplication:
```

Finally, let's create an `Multiply` class belonging to that package. For that, we place both the header and the source file in the `multiplication` directory.

```bash
$ touch multiplication/Multiply.cpp
$ touch multiplication/Multiply.h
```

Here's my silly implementation of this class:

```cpp
// Multiply.h
class Multiply {
public:
    Multiply(int number);
    int by(int other_number);

private:
    int number;
};
```

```cpp
// Multiply.cpp
#include <multiplication/Multiply.h>

Multiply::Multiply(int number) {
    this->number = number;
}

int Multiply::by(int other_number) {
    return this->number * other_number;
}
```

By design, both source and header files are placed in the same directory. Now, let's make use of the `Multiply` class by modifying the `main.cpp` file:

```cpp
// Main.cpp
/*
 * Automatically created with cpm
 */
#include <iostream>
#include <multiplication/Multiply.h>

using namespace std;

int main()
{
    cout << "multiply 6 x 8 = " << Multiply(6).by(8) << endl;
    return 0;
}
```

cpm will automatically solve the include directories required to make this work. Packages can be declared at any level. For example, if the package root directory is not contained directly under the root directory, for example, 

```
math/multiplication/Multiply.cpp
math/multiplication/Multiply.h
```

The project descriptor could be:

```yaml
name: awesome-project
build:
  packages:
    math/multiplication:
```

And then, the usage would still be the same:

```cpp
#include <multiplication/Multiply.h>
```

Nesting packages (packages inside other packages) is currently not supported.

### Bits

Bits are the way to share code with cpm. Bits are pieces of source code that can be downloaded and used in your project. Being in the form of source code, you can compile them for whatever target you require, as long as the bit is compatible for that target.

Let's say we want to make use of the <a href="https://cestframework.com/" rel="noopener" target="_blank">Cest</a> framework for our tests. We start by declaring the dependency in the project descriptor:

```yaml
name: awesome-project
build:
  packages:
    math/multiplication:
test:
  bits:
    cest: '1.0'
```

As you can see, as this is bit is only required for testing, we declare it in the `test` section of the project descriptor. Then, we can proceed to install the declared bits with:

```bash
$ cpm install
```

This command will detect which bits are not installed and will automatically download and install them. After having run this command, the project structure is updated as follows:

```
main.cpp
project.yaml
multiplication/Multiply.cpp
multiplication/Multiply.h
bits/cest/plugin.yaml
bits/cest/cest/cest.h
```

The source code for the installed project bits is kept in the `bits` directory. This directory should be treated as read-only and modifying it is not recommended.

### Testing

cpm is Test Driven Development ready. Currently, the official unit testing framework is <a href="https://cestframework.com/" rel="noopener" target="_blank">Cest</a>. Testing will be explained in a future tutorial, as this one is already quite long.

